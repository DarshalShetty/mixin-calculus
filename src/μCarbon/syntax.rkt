#lang typed/racket ;/no-check

(define-type Program (List 'program (Listof (U ClassDecl MixinDecl)) Term))
(define-type ClassDecl (List 'class Symbol
                             (Listof (U FieldDecl MethodDecl MixDecl))))
(define-type MixinDecl (List 'mixin Symbol (Listof (U MethodDecl MixDecl))))
(define-type FieldDecl (Pairof 'var VarDecl))
(define-type VarDecl (List Symbol ': Symbol))
(define-type MethodDecl (List 'fn Symbol (Listof VarDecl) '-> Symbol Term))
(define-type MixDecl (List 'mix Symbol))
(define-type Term (U Var FieldAcc MethodInv New))
(define-type Var Symbol)
(define-type FieldAcc (List '∘ Term Symbol))
(define-type MethodInv (List '∘ Term Symbol (Listof Term)))
(define-type New (List 'new Symbol (Listof Term)))

(struct decl () #:transparent)
(struct decl/class decl ((name : Symbol)
                         (fields : (Listof decl/var))
                         (methods : (Listof decl/method))
                         (mixes : (Listof decl/mix))) #:transparent)
(struct decl/var decl ((name : Symbol) (type : Symbol)) #:transparent)
(struct decl/method decl ((name : Symbol)
                          (params : (Listof decl/var))
                          (out-type : Symbol)
                          (body : term)) #:transparent)
(struct decl/mixin decl ((name : Symbol)
                         (methods : (Listof decl/method))
                         (mixes : (Listof decl/mix))) #:transparent)
(struct decl/mix decl ((mixee : Symbol)) #:transparent)

(struct term () #:transparent)
(struct term/var term ((x : Symbol)) #:transparent)
(struct term/field-acc term ((o : term) (f : Symbol)) #:transparent)
(struct term/method-inv term ((o : term)
                              (m : Symbol)
                              (args : (Listof term))) #:transparent)
(struct term/new term ((c : Symbol) (args : (Listof term))) #:transparent)

(struct program ((mixins : (Listof decl/mixin)) (classes : (Listof decl/class)) (main : term)) #:transparent)

(: parse (-> Program program))
(define (parse prog)
  (match-define `(program ,classes ,main) prog)
  (define classes-parsed (for/list : (Listof decl/class)
                                   ([c-decl : (U ClassDecl MixinDecl) classes]
                                    #:when (eqv? (car c-decl) 'class))
                           (parse-class c-decl)))
  (define mixins-parsed (for/list : (Listof decl/mixin)
                           ([m-decl : (U ClassDecl MixinDecl) classes]
                            #:when (eqv? (car m-decl) 'mixin))
                           (parse-mixin m-decl)))
  (program mixins-parsed classes-parsed (parse-term main)))

(: parse-mixin (-> MixinDecl decl/mixin))
(define (parse-mixin mixin-decl)
  (match-define `(mixin ,name ,members) mixin-decl)
  (define mixes (for/list : (Listof MixDecl)
                  ((m : (U MethodDecl MixDecl) members)
                   #:when (eqv? (car m) 'mix))
                  m))
  (define methods (for/list : (Listof MethodDecl)
                           ((m : (U MethodDecl MixDecl) members)
                            #:when (eqv? (car m) 'fn))
                   m))
  (define mixes-parsed (for/list : (Listof decl/mix)
                         ([mix : MixDecl mixes])
                         (match-define `(mix ,m) mix)
                         (decl/mix m)))
  (define methods-parsed (for/list : (Listof decl/method)
                           ([method : MethodDecl methods])
                           (parse-func method)))
  (decl/mixin name methods-parsed mixes-parsed))

(: parse-class (-> ClassDecl decl/class))
(define (parse-class class-decl)
  (match-define `(class ,name ,members) class-decl)
  (define fields (for/list : (Listof FieldDecl)
                           ((m : (U FieldDecl MethodDecl MixDecl) members)
                            #:when (eqv? (car m) 'var))
                   m))
  (define methods (for/list : (Listof MethodDecl)
                           ((m : (U FieldDecl MethodDecl MixDecl) members)
                            #:when (eqv? (car m) 'fn))
                   m))
  (define mixes (for/list : (Listof MixDecl)
                  ((m : (U MethodDecl MixDecl FieldDecl) members)
                   #:when (eqv? (car m) 'mix))
                  m))
  (define fields-parsed (for/list : (Listof decl/var)
                                  ([field : FieldDecl fields])
                          (match-define `(var ,name : ,type) field)
                          (decl/var name type)))
  (define methods-parsed (for/list : (Listof decl/method)
                                   ([method : MethodDecl methods])
                           (parse-func method)))
  (define mixes-parsed (for/list : (Listof decl/mix)
                         ([mix : MixDecl mixes])
                         (match-define `(mix ,m) mix)
                         (decl/mix m)))
  (decl/class name fields-parsed methods-parsed mixes-parsed))

(: parse-func (-> MethodDecl decl/method))
(define (parse-func func-decl)
  (match-define `(fn ,name ,params -> ,out-type ,body) func-decl)
  (define params-parsed (for/list : (Listof decl/var)
                                  ([param : VarDecl params])
                          (match-define `(,name : ,type) param)
                          (decl/var name type)))
  (decl/method name params-parsed out-type (parse-term body)))

(: parse-term (-> Term term))
(define (parse-term t)
  (match t
    [`,x #:when (symbol? x) (term/var x)]
    [`(∘ ,o ,f) #:when (symbol? f) (term/field-acc (parse-term o) f)]
    [`(∘ ,o ,m ,args) #:when (symbol? m)
                      (define parsed-args (for/list : (Listof term)
                                                    ([arg : Term args])
                                             (parse-term arg)))
                      (term/method-inv (parse-term o) m parsed-args)]
    [`(new ,c ,args) #:when (symbol? c)
                     (define parsed-args (for/list : (Listof term)
                                           ([arg : Term args])
                                           (parse-term arg)))
                     (term/new c parsed-args)]))

(struct type/method ([doms : (Listof Symbol)] [rng : Symbol]) #:transparent)

(struct value () #:transparent)
(struct value/object value ((c : Symbol) (args : (Listof value))) #:transparent)

(provide (all-defined-out))
